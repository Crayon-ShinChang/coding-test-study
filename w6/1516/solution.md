## 풀이 전략

### 1. **그래프 모델링**
- 각 건물을 정점(Node)으로 보고, "A 건물이 B 건물보다 먼저 지어져야 한다"라는 조건을 간선(Edge)로 표현합니다.
- 순서 제약이 있는 방향성 그래프(Directed Acyclic Graph, DAG)로 모델링합니다.

### 2. **위상정렬(Topological Sort) 기반 누적 시간 계산**
- "특정 건물을 짓기 위해 필요로 하는 모든 선행 건물 공사가 끝난 후 시작할 수 있다"는 점에서, 위상 정렬을 통해 각 건물을 착공 가능한 모든 조건이 충족됐을 때 지을 수 있음이 보장됩니다.
- **BFS 방식의 위상정렬**을 활용하여 건물을 차례로 짓고, 각 건물별 최대 누적 대기시간(선행 건물이 모두 완공될 때까지 기다리는 시간)을 계산합니다.

### 3. **구현 흐름(코드 요약)**
#### 1) **입력 및 데이터 구조 준비**
- 각 건물별로:
    - 시간(`times[]`)
    - 다음에 지어질 건물 리스트(`buildings[]`)
    - 선행된 건물의 개수(`degrees[]`, 진입 차수)를 저장

#### 2) **위상정렬 시작**
- 차수가 0인(선행 건물이 없는, 바로 지을 수 있는) 건물들을 큐에 삽입

#### 3) **BFS 방식으로 순차 처리**
- 큐에서 건물을 꺼내어, 해당 건물 다음에 지어질 건물의 최소 대기 시간을 갱신(`answer[next] = max(answer[next], answer[now] + times[now])`)
- 선행 건물을 모두 처리한(차수가 0이 된) 건물들을 다시 큐에 삽입

#### 4) **최종 건물별 소요시간 산출**
- 해당 건물에 도달하는 데 필요한 최대 누적 대기 시간(answer[i])과 해당 건물 자체를 짓는 시간(times[i])의 합이 최종 소요시간

## 핵심 함수/로직 설명
- **solution()** :
    - 위상 정렬, 누적 건설 대기 시간 배열(answer[]) 관리
    - 각 건물별 최대 대기시간을 최신화하면서, 선행 건물 수가 0이 되면 큐에 넣음
    - 위상정렬 종료 시 각 건물별 최소 완공 시간 산출