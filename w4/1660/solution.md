## 문제 요약

- **정사면체 포탄**은 특정한 규칙을 가진 대포알의 모양
    - 1층: 1개
    - 2층: 3개 (1 + 2)
    - 3층: 6개 (1 + 2 + 3)
    - 4층: 10개 (1 + 2 + 3 + 4) ...
    - 이들을 누적해서 쌓음 —> ∑ₖ∑₁ᵏi = **정사면체 수열**
- 주어진 `N`개의 대포알로 **최소 몇 개의 정사면체 포탄을 만들 수 있는가?** 를 구하는 문제.
- 단순히 "딱 맞게" 포탄을 만드는 것이 아니라, 대포알을 다 쓰면서 가능한 최소 개수의 정사면체 포탄으로 만들어야 함.

## 핵심 개념

- **정사면체 수열(Tetrahedral Numbers)**:
    - `T(k) = k * (k + 1) * (k + 2) / 6`
    - 계차수열로 나타낼 수 있으며, 점화식으로도 계산 가능
- 이 문제는 **정사면체 수열을 동전처럼 사용하여 N을 표현하되, 동전 개수를 최소화**하는 것과 같음
- 즉, **동전 교환 문제 (Dynamic Programming)** 유형

## 로직 설명

### 정사면체 수 생성

```java
dp[0] = 0;
dp[1] = 1;
int num = 1;
int idx = 1;
while (dp[idx]  i) break;

        if (cnt[i] == -1 || cnt[i] > cnt[i-dp[j]] + 1) {
            cnt[i] = cnt[i-dp[j]] + 1;
        }
    }
}
```

- **동전 교환 알고리즘**의 원리와 동일
- `cnt[i]`: i개의 대포알로 정사면체를 만들 수 있는 **최소 개수**
- 점화식
  ```java
  cnt[i] = min(cnt[i], cnt[i - dp[j]] + 1)
  ```
- 반복해서 필요한 만큼 갱신하면됨

## 📌 시간 복잡도

- 정사면체 수열 최대 100개 이하
- `O(N × log N)` 정도 예상되는 효율적인 완전 탐색