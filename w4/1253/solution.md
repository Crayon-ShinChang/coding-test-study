# 백준 1253: 좋다
### 1. 문제 이해
수열에 존재하는 수들 중에서 자신을 두 수의 합으로 만들 수 있는 수의 개수를 찾는 문제.
- 수열의 모든 수는 자연수 또는 0, 중복 가능
- 두 수는 같은 수일 수 있지만, 같은 인덱스는 사용할 수 없음

주어진 수열 A에서, 자기 자신을 x라 할 때 A[i] + A[j] == x를 만족하는 (i ≠ j ≠ x의 인덱스) 쌍이 있으면, x는 ‘좋은 수’

예를 들어 입력된 수열이 1 2 3 4 5라면, 4는 1+3 또는 2+2가 아닌 1+3 등으로 표현되므로 ‘좋은 수’. **중요한 점은 같은 값이어도 서로 다른 인덱스를 사용**해야 한다는 것

### 2. 문제 접근 방식 (투 포인터 활용)
이 문제는 모든 수 A[k]에 대해, 다른 두 수 A[i], A[j]를 합쳐 A[k]를 만들 수 있는지 판단하는 것이 핵심이므로 정렬 후 **투 포인터**를 이용해 문제 풀이

모든 수 A[k]에 대해 하나씩 판단
- A[k]를 목표 수(target)으로 보고, 이 수를 만들 수 있는 두 수 A[i] + A[j] 쌍이 있는지 확인
- 이때 투 포인터를 활용하여 **A ~ A[N-1] 범위에서 i + j == A[k]**인 쌍을 찾는데, 단 i와 j는 k와 다른 인덱스.
- 포인터 이동 시 자기 자신(k)을 건너뛰고, 합의 비교 결과에 따라 좌우 포인터를 이동.
- 조건 만족 시 해당 수는 ‘좋은 수’: 한번이라도 만족하는 경우, 결과 카운트를 하나 증가.

### 3. 핵심 구현 로직
정렬된 수열 기준으로 모든 원소 A[k]에 대해 투 포인터로 탐색

- 왼쪽 포인터(left), 오른쪽 포인터(right) 설정
- 두 인덱스 중 하나라도 k라면 스킵하고 다음
- A[left] + A[right] > A[k] → right--
- A[left] + A[right] < A[k] → left++
- 정합이면 카운트 증가 후 루프 탈출

전체 수에 대해 위 과정을 반복하여 최종 ‘좋은 수’ 개수 계산

