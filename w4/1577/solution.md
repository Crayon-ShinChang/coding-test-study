# 백준 1577: 도로의 개수
### 1. 문제 이해
(0,0)에서 (N,M)까지 이동하는 최단 경로의 개수 계산. 특정 도로는 공사 중이어서 지나갈 수 없음.
- 시작점: (0,0)
- 도착점: (N,M) (N, M은 1 이상 100 이하의 자연수)
- 이동 규칙: 가로 또는 세로로만 한 칸씩 이동. 즉, (x,y)에서 (x+1,y) 또는 (x,y+1)로만 이동 가능.
- 최단 경로: 항상 가로로 N번, 세로로 M번 이동해야 함. 총 이동 횟수는 N + M번.
- 공사 중인 도로: 입력으로 주어지는 (x1, y1, x2, y2)는 공사 중인 도로 표시. 이 도로는 양방향 공사 중으로, (x1, y1)에서 (x2, y2)로도, (x2, y2)에서 (x1, y1)로도 이동 불가.

결론적으로 (0,0)에서 (N,M)까지 최단 경로로 이동하는 방법 중 공사 중인 도로를 포함하지 않는 경로의 개수 산출.

### 2. 문제 접근 방식 (동적 계획법 - Dynamic Programming 활용)
최단 경로 개수 계산이므로, 특정 지점까지 도달하는 경로 수를 이전 지점들로부터 누적하여 계산하는 방식 활용.

- DP 테이블 정의: dp[i][j]를 (0,0)에서 (i,j) 지점까지 도달하는 최단 경로의 개수 정의.
- dp[0][0] = 1로 초기화. (시작점에 도달하는 방법 1가지)
- 나머지 dp 값은 0으로 초기화.
- 점화식: (i,j)에 도달하는 경로 두 가지 경우의 합.
    - (i-1, j)에서 오른쪽으로 이동
    - (i, j-1)에서 아래쪽으로 이동
    - dp[i][j] = dp[i-1][j] + dp[i][j-1].

- 공사 중인 도로 처리:
    이 점화식은 공사 중인 도로가 없을 때 유효. 공사 중인 도로가 있다면, 해당 도로를 통한 이동 불가이므로, dp 값 누적 시 해당 경로 제외.

### 3. 핵심 구현 로직
- DP 테이블 초기화:
    - long[][] dp = new long[N + 1][M + 1]; (테케 숫자가 좀 커서, Long으로 함)
    - dp[0][0] = 1;

- 공사 중인 도로 정보 저장:
    - 공사 중인 도로로는 이동할 수 없으므로 boolean 3차원 배열에 공사 정보를 저장
    - blocked[x][y][d]:
        - 양방향 통제이긴 하지만, 문제에서 N+M의 거리(맨해튼 거리)로만 이동한다 했으니, 좌방향이나 상방향으로 이동하는 경우는 없음. 그래서 단방향으로 블락해도 문제가 없음
        - x: 공사 시점 x 좌표
        - y: 공사 종점 y 좌표
        - d: 방향


- DP 테이블 채우기:
    - dp[i][j] 계산 시:
        - 왼쪽에서 오는 경우: dp[i][j] += dp[i-1][j] (단, i > 0이고 (i-1, j)에서 (i, j)로 가는 길이 공사 중 아닐 때만 포함)
        - 위쪽에서 오는 경우: dp[i][j] += dp[i][j-1] (단, j > 0이고 (i, j-1)에서 (i, j)로 가는 길이 공사 중 아닐 때만 포함)