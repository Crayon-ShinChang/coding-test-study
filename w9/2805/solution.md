# BOJ 2805번: 나무 자르기 (이분 탐색) 문제 풀이

## 1. 문제 개요
- **입력**
    - `N`: 나무의 개수 (1 ≤ N ≤ 1,000,000)
    - `M`: 필요한 나무의 길이 (1 ≤ M ≤ 2,000,000,000)
    - 나무의 각 높이 (1 ≤ 높이 ≤ 1,000,000,000)
- **조건**
    - 절단기 높이(H)를 정해서, 각 나무를 H위로 잘라 잘린 윗 부분만 가져감
    - 합쳐서 적어도 M만큼 가져가야 함
    - 가능한 한 최대의 H(높이)를 구해야 함
- **목표**
    - 필요한 총 나무 길이 M을 구할 수 있는 절단기 높이 H의 최댓값 출력

---

## 2. 핵심 아이디어
- **이분 탐색(Binary Search)**을 활용하여 최적의 절단기 높이(H) 찾기
- 매번 H(mid)에서 잘라보며 잘린 나무 총합이 M 이상인지 확인
    - sum ≥ M: H를 더 높여 시도(min = mid+1)
    - sum < M: H를 낮춰야 함(max = mid-1)
- H의 최댓값을 계속 갱신

---

## 3. 최적화 포인트
- **정렬:** 가장 긴 나무를 찾기 위해 정렬(시간복잡도 영향 없음)
- **이분 탐색:** O(N log(max 높이))로 빠르게 탐색
- **탐색 과정:** mid보다 큰 나무만 sum 계산

---

## 4. 알고리즘 절차
1. 입력 처리 및 배열 초기화
    - N, M, 나무 배열 입력
2. 정렬 후 max 탐색
    - Arrays.sort(arr)
    - max = arr[N-1]
3. 이분 탐색
    - min = 0, max = 나무의 최고 높이
    - while (min ≤ max)
        - mid = (min + max)/2
        - sum = 자른 나무 총길이 (mid보다 큰 것만)
        - if (sum ≥ M): answer=mid; min=mid+1
        - else: max=mid-1
4. 결과 출력
    - answer 출력

---

## 5. 복잡도 분석
- **시간 복잡도:** O(N log(max 높이))
- **공간 복잡도:** O(N)
