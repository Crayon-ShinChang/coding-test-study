## 풀이 전략 (solution.md 스타일)

### 1. **이분 탐색(이진 탐색, Binary Search) + greedy**
- 휴게소 사이의 '최대 거리 간격'을 최소로 만드는 문제이므로, **간격의 최솟값을 이분 탐색**으로 결정
- 매 이분 탐색 중, 주어진 최대 간격(`mid`)으로 만들 수 있을 때 필요한 '휴게소의 개수'를 모두 계산(그리디 방식)
- '휴게소를 M개 이하만큼만 추가로 설치할 수 있으면 된다'는 조건 하에, 가능한 한 최대 간격을 최소화

### 2. **Binary Search로 간격 줄이기**
- 탐색의 시작점은 최소 간격(1), 끝점은 도로의 전체 길이(L)로 설
- 이분 탐색의 중간값(`mid`)를 후보 간격으로 잡고, 모든 휴게소 구간마다 '해당 간격을 넘지 않게정해 필요한 휴게소 수'를 반복적으로 계산
- 만약 필요한 휴게소 수가 M보다 많으면, 간격을 늘리고(`start = mid + 1`), 적거나 같으면 더 좁힐 수 있으니(`end = mid - 1`) 탐색을 진행

### 3. **여유 조건 및 "greedy" 적용**
- **그리디 요소**: 각 구간마다 간격마다 최대한 많은 휴게소를 한 번에 설치(최솟값이 되게끔)
- 불필요하게 휴게소를 많이 설치하는 경우를 탐색 과정에서 자연스럽게 제거
- 최적의 간격의 하한값(`start`)을 이분 탐색의 정답으로 반환

### 4. **핵심 함수/로직 요약**
- **이분 탐색 loop**: 간격 후보를 줄이며 휴게소 개수 조건 만족하는지 판단
- **계산 반복**: 각 구간마다 `(구간 길이 - 1) / 간격` 공식을 이용, 필수 설치 개수 계산
- **최적 start 반환**: 조건 만족하는 가장 작은 간격 반환
