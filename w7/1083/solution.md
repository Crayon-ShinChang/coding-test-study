## 풀이 전략

### 1. **최대 교환 횟수로 만드는 최대 배열 (Greedy)**
- 입력으로 주어지는 수열에서 최대한 큰 수가 앞에 오도록 "주어진 교환 횟수"만큼 최적의 자리를 찾아가며 정렬
- 매번 현재 위치에서, '앞으로 이동할 수 있는 범위 내에서 가장 큰 수'를 선택해 앞에 위치
- 이 과정을 반복하여 교환 횟수 한도 내에서 가장 큰 수열을 생성

### 2. **정렬 종료 조건 및 최적화**
- 만약 남은 교환 횟수가 버블 소트의 최대 교환 횟수($$ n(n-1)/2 $$)보다 크다면, 이미 모든 경우를 뒤집을 수 있으므로 **내림차순 정렬**이 정답.
- 그렇지 않다면, 반복문마다 이동할 수 있는 최대 거리(`s` 남은 횟수)만큼만 탐색하여 최대원소를 앞으로 이동

### 3. **최적 부분 선택 및 교환**
- 각 위치마다 `k+1`부터 `k+s`까지(범위 내) 가장 큰 값을 골라서 앞으로 한 칸씩 밀며 자리를 바꾸는 방식(이동 간 swap 반복).
- 실제 교환 횟수는 최대값의 현재 위치에서 앞자리까지 이동하는 거리(`maxIdx - k`)만큼 차감.
- 이 과정을 **교환 횟수가 0이 될 때까지** 반복

## 핵심 함수/로직

- **Greedy Swap Loop:**  
  한 번마다 현재 위치 이외에 최대한 앞으로 보낼 수 있는(남은 교환 범위 내) 가장 큰 값을 찾아 앞으로 이동
- **조기 내림차순 처리:**  
  이미 최대 교환 횟수 이상이 가능하면 바로 내림차순 정렬을 반환
- **swap 반복:**  
  구한 최댓값을 한 칸씩 앞자리와 swap