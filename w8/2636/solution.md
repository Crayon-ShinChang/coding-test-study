# BOJ 2636번: 치즈 녹이기 문제 풀이

## 1. 문제 개요
- `N x M` 보드에서
    - `1`: 치즈
    - `0`: 빈 칸(공기)
- 매 시간마다 **외부 공기와 접촉하는 치즈**가 모두 녹는다.
- 구해야 할 것:
    1. 모든 치즈가 녹는 데 걸린 시간
    2. 완전히 녹기 직전 남아있는 치즈 개수

---

## 2. 핵심 아이디어
- **BFS로 외부 공기 판별 + 시뮬레이션 반복**
1. `(0,0)`에서 BFS를 돌려 외부 공기(`outside[][]`)를 찾는다.
    - 이렇게 하면 내부 구멍(공기)는 제외하고 *실제 녹일 수 있는 치즈*를 정확히 판별 가능.
2. 외부 공기와 한 변이라도 맞닿은 치즈를 녹인다.
3. 반복하면서 전체 시간이랑 마지막 치즈 개수를 구한다.

---

## 3. 최적화 포인트
- **현재 상태 보존**
    - 같은 턴에서 치즈를 녹이는 여부를 판단할 때는 `board`를 직접 수정하지 않고 `prev` 복사본 사용.
- **외부 공기 visited 배열 재활용**
    - 턴마다 `outside[][]` 새 생성 → 간단하고 안전.
- **조기 종료**
    - 치즈 개수가 0이면 즉시 종료.

---

## 4. 상세 알고리즘 흐름

### 4.1 외부 공기 탐색 (`markOutsideAir`)
1. `(0,0)`에서 BFS 시작.
2. 빈 칸(`0`)이면서 아직 방문하지 않은 칸이면 외부 공기로 표시.
3. 상하좌우로 확장.

### 4.2 치즈 녹이기 (`melt`)
1. `prev` 배열에 현재 보드 복사.
2. 외부 공기 배열(`outside[][]`)을 받아서
    - 외부 공기와 접촉한 치즈는 모두 0으로 변경.
3. 나머지 치즈는 그대로 유지.

### 4.3 메인 시뮬레이션 (`solution`)
1. 현재 치즈 개수(`countCheese`) 계산.
2. 0이면 종료.
3. 그렇지 않으면 `마지막 치즈 개수` 갱신.
4. `melt()` 호출 → 시간 +1
5. 반복.

---

## 5. 주요 함수 정리
- **`markOutsideAir(int[][] prev)`** : BFS로 외부 공기 판별
- **`countCheese()`** : 현재 남은 치즈 개수 세기
- **`melt()`** : 외부 공기에 접한 치즈 제거
- **`solution()`** : 시간 경과 시뮬레이션, 종료 조건 체크

---

## 6. 복잡도 분석
- **시간 복잡도:**
    - 매 턴 BFS + 전체 보드 순회 ⇒ `O(T * N * M)`  
      (`T`는 녹는 데 걸린 총 시간)
- **공간 복잡도:**
    - 보드 2개(`prev`, `board`) + 외부 공기 체크 배열 ⇒ `O(N * M)`

---