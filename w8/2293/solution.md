# BOJ 2293번: 동전 1 문제 풀이

## 1. 문제 개요
- **입력**
    - `N`: 동전의 종류 개수 (1 ≤ N ≤ 100)
    - `K`: 목표 금액 (1 ≤ K ≤ 10,000)
    - 각 동전의 금액 (중복 없음, 오름차순 아니어도 됨)
- **조건**
    - 같은 종류 동전은 개수 제한 없이 사용 가능
    - 순서만 다른 경우는 동일한 경우로 처리  
      예: 1원 + 2원 == 2원 + 1원
- **목표**
    - 금액 `K`를 만드는 모든 경우의 수를 구하기

---

## 2. 핵심 아이디어
- **1차원 DP**로 경우의 수 계산
- `dp[x]` = 금액 `x`를 만드는 경우의 수
- 중복 계산을 피하려면 "동전 → 금액" 순으로 반복

**점화식**
 - dp = 1 // 0원을 만드는 경우 1가지 
 - for i in 1..N: // 각 동전에 대하여
    - for j = coin[i] to K: // 목표 금액까지
      - dp[j] += dp[j - coin[i]]

---

## 3. 최적화 포인트
- **1차원 배열 사용**: 중복 카운트 방지 및 메모리 절약
- 금액 `j`를 **오름차순**으로 갱신하여 순서가 다른 경우를 따로 세지 않음
- 초기값 `dp[0] = 1` 필수

---

## 4. 알고리즘 절차
1. 입력 처리
    - `N`, `K` 값과 동전 금액 배열 입력
2. DP 배열 초기화
    - 크기: `K+1`
    - `dp[0] = 1`
3. 경우의 수 계산
    - 각 동전에 대해 금액 반복문 수행
    - `dp[j] += dp[j - coin[i]]`
4. 결과 출력
    - `dp[K]`

---

## 5. 복잡도 분석
- **시간 복잡도**: `O(N * K)`
- **공간 복잡도**: `O(K)`

---