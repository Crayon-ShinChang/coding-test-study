# 백준 1744: 수 묶기
### 1. 문제 이해
- 문제에서 수열이 주어진다, 해당 수열에 존재하는 수들을 모두 더하여 값을 구할 수 있다.
- 이 문제에서는 수열을 조작하여 값을 늘릴 수 있다. 그것을 '수 묶기'라고 한다.
- '수 묶기'는 서로 다른 두 수를 곱하여 하나의 수로 묶는 방법이다.
- 예를 들면, {0, 1, 2, 3, 4} 라는 수열이 존재할 때, 3과 4를 묶어 12로 만들어 {0, 1, 2, 12} 라는 새로운 수열을 만들어낼 수 있다.
- '수 묶기'의 제한 횟수는 존재하지 않는다, **적절하게 '수 묶기'를 수행하여 구할 수 있는 최대의 값을 찾는 문제**이다.

### 2. 문제 접근 방식 (그리디)
- 서로 다른 부호를 가진 두 수를 묶으면 그 수는 음수가 되어버린다.
    - 즉, 서로 다른 부호를 묶는 방법은 정답을 구할 수 없다.
    - 음수와 양수를 격리해야 한다.
- 두 수를 곱할 때, 절대값이 큰 수끼리 곱해야 그 증가분이 상승한다.
    - 수열을 정렬하여 큰 수끼리 수를 묶기 용이하도록 해야한다.
    - 두 개의 PriorityQueue를 사용하여, 음수와 양수를 담는 컬렉션으로 활용한다.
- 1은 곱셈의 항등원이다. 즉 1과 묶어봐야 같은 수가 나오기에 1은 묶지 않고 그냥 더하는 것이 최적이다.
- 0과 수를 묶으면 그 수는 0이 된다. 이는 음수를 상쇄할 때 사용가능하다.
    - 수열에서 음수의 개수가 짝수개라면 모든 수가 짝수를 이루어 음수가 발생하지 않으나 홀수개라면 음수가 발생한다.
    - 만약, 수열에서 0이 존재한다면 0과 묶어서 수를 상쇄할 수 있게 된다.

### 3. 핵심 구현 로직
#### 3-1. 음수와 양수 격리
두 개의 PriorityQueue를 사용하여 음수와 양수를 격리하여 저장한다.
``` java
PriorityQueue<Integer> nQ = new PriorityQueue<>(Collections.reverseOrder());
PriorityQueue<Integer> pQ = new PriorityQueue<>(Collections.reverseOrder());
```

#### 3-1-1. PQ에서 음수 저장
음수를 내림차순으로 저장한다면, 절대값이 작은 순으로 정렬이 될 것이다. 즉, 별도의 처리를 하여 정렬 기준을 조작해야 한다.
필자의 경우 그냥 -1을 곱하여 양수의 형태로 저장하였다.
``` java
if (num < 0) nQ.add(-1 * num);
```

#### 3-2. 1에 대한 처리
2절에서 말했던 것처럼 1은 곱셈의 항등원이므로, 수를 묶는데에 사용하는 것보단 그냥 더하는 것이 이득이다.
따라서, 1이 입력된다면 값에 더해준다.
``` java
else if (num == 1) answer++;
```

#### 3-3. 0에 대한 처리
0은 결과에 영향을 주지 않으나, 음수를 상쇄하는 와일드카드로 사용될 수 있다.
따라서 수열에서 0이 존재하는지를 기억해둬야 한다.
``` java
else if (num == 0) hasZero = true;
```


