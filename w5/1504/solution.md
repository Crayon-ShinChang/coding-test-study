## 문제 요약

- 양방향 그래프가 주어짐.
- 1번 정점에서 N번 정점까지 가는 최단 경로를 구함
- 단, 경로상에 반드시 주어진 두 정점(v1, v2)을 모두 지나야 함 (순서는 상관없음)
- 경로가 없다면 -1을 출력

## 풀이 전략

### 1. **최단 경로 알고리즘**

- 그래프의 각 정점 사이의 최단 경로를 구해야 하므로 **다익스트라(Dijkstra)** 알고리즘을 사용
- 간선 가중치가 모두 양수이므로 다익스트라가 효율적

### 2. **꼭 거쳐야 할 정점(v1, v2)가 순서 상관없이 포함되어야 하므로, 가능한 경우의 수는 두 가지**

- 1 → v1 → v2 → N
- 1 → v2 → v1 → N

각 경우의 총 거리를 비교해 더 짧은 쪽을 답으로 선택

### 3. **필요한 경로의 최소 비용 계산**

- 각각의 경우를 계산하기 위해, 다음 지점 간 최단 거리를 구해야 함

    - 1번 → v1번
    - 1번 → v2번
    - v1번 → v2번
    - v1번 → N번
    - v2번 → N번

- 각각을 미리 **다익스트라** 알고리즘 한 번씩 돌려 모두 구해 놓으면, 위의 두 경로 중 각 구간의 최단 거리 합을 계산

### 4. **불가능한 경우 체크**

- 다익스트라로 구한 거리 값이 -1(또는 무한)이라면 경로가 없는 것
- 두 경로 모두 불가능하다면 `-1`을 출력

## 구현 흐름(코드 요약)

1. **입력 처리 및 그래프 생성**
    - 간선 정보를 `ArrayList`에 저장(양방향)
    - 반드시 거쳐야 하는 정점 번호(v1, v2) 입력

2. **최단 거리 구하기**
    - 1번 정점, v1, v2에서부터 각각 모든 정점까지의 최단 거리를 다익스트라로 계산해서 저장

3. **총 경로 길이 계산**
    - 1 → v1 → v2 → N 경로의 길이와, 1 → v2 → v1 → N 경로의 길이를 각각 계산
    - 경로가 없는 경우(-1)에 대한 예외 처리

4. **정답 출력**

## 핵심 함수

- `dijkstra(int start)` : 특정 시작점에서 각 정점까지의 최단 거리를 구하는 함수
- `solution()`
    - 위에서 설명한 두 방법(경로)의 최단 거리를 비교하고, 둘 중 짧은 길이를 반환
    - 만약 두 방법 다 갈 수 없으면 -1 반환

## 정리

- 다익스트라로 (1, v1, v2)에서 출발 시의 최단경로를 모두 계산
- 1 → v1 → v2 → N 과 1 → v2 → v1 → N 두 가지의 경로 합 중 더 짧은 값을 정답으로 출력